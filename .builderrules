# .builderrules for Frappe Framework App Development
# This file guides Builder.io CLI on how to generate code for Frappe applications

# ===== FRAPPE FRAMEWORK CONVENTIONS =====

# Project Structure
Follow the standard Frappe app directory structure:
- Root level: setup.py, requirements.txt, MANIFEST.in, README.md
- App directory: {app_name}/ containing __init__.py, hooks.py, modules.txt, patches.txt
- Module directories: {app_name}/{module_name}/ with __init__.py
- DocType directories: {app_name}/{module_name}/doctype/{doctype_name}/
- API directories: {app_name}/api/ for REST API endpoints
- Config directories: {app_name}/config/ for desktop.py, workspace.py
- Templates: {app_name}/templates/ for web templates
- Public assets: {app_name}/public/ for CSS, JS, images

# ===== PYTHON CODING CONVENTIONS =====

# General Python Guidelines
Use Python 3.6+ syntax and features
Follow PEP 8 style guidelines for Python code
Use snake_case for function names, variables, and file names
Use PascalCase for class names and DocType names
Add docstrings to all functions and classes using Google style
Use type hints where appropriate

# Frappe-specific Python Patterns
Import frappe at the top of Python files: import frappe
Use frappe.whitelist() decorator for API methods accessible via REST
Use frappe.get_doc() to fetch documents, frappe.get_all() for lists
Handle exceptions with frappe.throw() for user-facing errors
Use frappe.log_error() for logging errors
Validate permissions with frappe.has_permission()
Use frappe.db.get_value() for single field queries
Use frappe.utils for date/time operations and utilities

# DocType Controller Classes
Create controller classes that inherit from frappe.model.document.Document
Override validate(), before_save(), after_insert(), on_submit() methods as needed
Use self.get() and self.set() to access and modify field values
Implement custom validation logic in validate() method
Use frappe.msgprint() for user notifications

# ===== JAVASCRIPT CONVENTIONS =====

# Client-side JavaScript (DocType JS)
Use frappe.ui.form.on() to bind form events
Access form fields with frm.doc.fieldname
Use frm.set_value() to update field values programmatically
Implement field validation with frappe.validated = false
Use frappe.call() for server-side method calls
Handle async operations with promises or async/await
Use frappe.msgprint() for user notifications

# Modern JavaScript Practices
Use ES6+ features: const/let, arrow functions, template literals
Use async/await for asynchronous operations
Implement proper error handling with try/catch blocks
Use destructuring for object and array operations
Prefer functional programming patterns where appropriate

# ===== API DEVELOPMENT =====

# REST API Endpoints
Place API methods in {app_name}/api/ directory
Use @frappe.whitelist() decorator for all API endpoints
Return JSON responses with consistent structure
Implement proper error handling and status codes
Use frappe.form_dict to access request parameters
Validate input parameters and permissions
Document API endpoints with docstrings

# API Response Format
Return consistent JSON structure: {"message": "success", "data": {...}}
Use HTTP status codes appropriately (200, 400, 401, 404, 500)
Include error messages in response for failed requests
Implement pagination for list endpoints

# ===== DOCTYPE DEVELOPMENT =====

# DocType JSON Schema
Use lowercase with underscores for fieldnames (e.g., "full_name")
Set appropriate fieldtypes: Data, Text, Select, Link, Date, Datetime, Check, etc.
Configure field properties: label, mandatory, read_only, hidden, depends_on
Set up proper field ordering with field_order array
Configure permissions for different roles
Set naming patterns using naming_rule and autoname

# DocType Field Guidelines
Use Link fields for relationships to other DocTypes
Set fetch_from property to auto-populate fields from linked records
Use Select fields with options for predefined choices
Implement field dependencies with depends_on property
Set default values where appropriate
Configure field validation with validation rules

# ===== HOOKS.PY CONFIGURATION =====

# App Metadata
Define app_name, app_title, app_publisher, app_description, app_email
Set app_license (typically "MIT" or "GPL")
Configure app_include_css and app_include_js for global assets
Set up desktop and workspace configurations

# Event Hooks
Use doc_events to hook into document lifecycle events
Configure scheduler_events for background tasks
Set up authentication hooks if needed
Define custom permissions with permission_query_conditions

# ===== TESTING CONVENTIONS =====

# Unit Tests
Create test files with test_ prefix in doctype directories
Use frappe.test_runner for running tests
Inherit from unittest.TestCase or frappe.tests.utils.FrappeTestCase
Create test data using frappe.get_doc().insert()
Clean up test data in tearDown() method
Test both positive and negative scenarios

# ===== SECURITY BEST PRACTICES =====

# Permission Management
Always check permissions before data operations
Use frappe.has_permission() to validate access
Implement role-based access control
Validate user input to prevent injection attacks
Use frappe.safe_decode() for user input processing
Implement CSRF protection for forms

# ===== PERFORMANCE GUIDELINES =====

# Database Operations
Use frappe.db.get_all() with specific fields instead of get_doc() for lists
Implement database indexes for frequently queried fields
Use frappe.db.sql() for complex queries with proper parameterization
Avoid N+1 query problems by batching operations
Use caching with frappe.cache() for expensive operations

# ===== FILE ORGANIZATION =====

# Module Structure
Group related DocTypes in the same module
Keep API endpoints organized by functionality
Separate utility functions into utils.py files
Use __init__.py files to make directories Python packages
Follow consistent naming conventions across the project

# ===== DOCUMENTATION =====

# Code Documentation
Add comprehensive docstrings to all public functions and classes
Include parameter types and return value descriptions
Document complex business logic with inline comments
Create README.md files for modules explaining their purpose
Document API endpoints with request/response examples

# ===== INTEGRATION PATTERNS =====

# Third-party Integrations
Create separate modules for external service integrations
Use environment variables for API keys and configuration
Implement proper error handling for external API calls
Add retry logic for network operations
Log integration activities for debugging

# ===== NEXT.JS FRONTEND DEVELOPMENT =====

# Project Structure and Architecture
Follow Next.js 13+ App Router conventions with app/ directory structure
Organize components in src/components/{feature}/{ComponentName}.tsx
Use TypeScript for all frontend code with strict type checking
Implement proper separation between Server Components and Client Components
Create reusable UI components following atomic design principles
Use barrel exports (index.ts) for clean component imports

# Next.js App Router Patterns
Use app/layout.tsx for root layout with proper metadata configuration
Implement page.tsx files for route definitions
Use loading.tsx, error.tsx, and not-found.tsx for UI states
Create route groups with (groupName) for organization
Implement parallel routes with @folder notation when needed
Use intercepting routes with (.) notation for modals and overlays

# React Component Development
Use functional components with TypeScript interfaces for props
Implement proper prop validation with TypeScript
Use React hooks (useState, useEffect, useCallback, useMemo) appropriately
Create custom hooks for reusable logic
Implement proper error boundaries for component error handling
Use React.memo() for performance optimization when appropriate

# State Management Patterns
Use React Query (TanStack Query) for server state management
Implement Zustand or Context API for client-side global state
Use React Hook Form for form state management
Implement proper loading and error states for all async operations
Use optimistic updates for better user experience
Cache API responses appropriately with React Query

# ===== FRAPPE + NEXT.JS INTEGRATION =====

# API Integration Patterns
Use frappe-react-sdk or custom hooks for Frappe API calls
Implement proper authentication flow with Frappe sessions
Create TypeScript interfaces for all Frappe DocType responses
Use consistent API response handling across the application
Implement proper error handling for Frappe API errors
Use SWR or React Query for data fetching and caching

# Authentication Integration
Implement session-based authentication with Frappe backend
Create authentication context provider for user state management
Use Next.js middleware for route protection and authentication checks
Implement proper login/logout flows with Frappe authentication endpoints
Handle authentication errors and token refresh appropriately
Store authentication state securely (httpOnly cookies recommended)

# Frappe API Consumption
Create typed API client functions for Frappe endpoints
Use frappe.call() patterns adapted for frontend consumption
Implement proper CSRF token handling for Frappe requests
Create reusable hooks for common Frappe operations (get_doc, get_list, etc.)
Handle Frappe-specific error responses and status codes
Implement file upload functionality with Frappe file handling

# Data Fetching Strategies
Use Server Components for initial data loading when possible
Implement Client Components for interactive data operations
Use React Query for caching and synchronization with Frappe backend
Implement proper loading states and skeleton components
Handle offline scenarios and network errors gracefully
Use optimistic updates for better perceived performance

# ===== TYPESCRIPT INTEGRATION =====

# Type Definitions
Create TypeScript interfaces for all Frappe DocTypes
Generate types from Frappe schema definitions when possible
Use strict TypeScript configuration with proper type checking
Implement proper typing for API responses and requests
Create utility types for common Frappe patterns
Use generic types for reusable components and hooks

# API Type Safety
Define interfaces for all Frappe API endpoints
Use discriminated unions for different response types
Implement proper error type definitions
Create type guards for runtime type checking
Use branded types for IDs and specific string formats
Implement proper typing for form data and validation

# ===== STYLING AND UI PATTERNS =====

# CSS and Styling
Use Tailwind CSS for utility-first styling approach
Implement consistent design system with CSS custom properties
Create reusable component variants with class-variance-authority
Use CSS Modules or styled-components for component-specific styles
Implement responsive design patterns with mobile-first approach
Follow accessibility guidelines (WCAG 2.1) for all UI components

# Component Library Integration
Use shadcn/ui or similar component library for consistent UI
Customize component themes to match brand requirements
Implement proper component composition patterns
Create consistent spacing and typography scales
Use proper color schemes with dark/light mode support
Implement consistent form styling and validation feedback

# ===== PERFORMANCE OPTIMIZATION =====

# Next.js Performance
Use Next.js Image component for optimized image loading
Implement proper code splitting with dynamic imports
Use React.lazy() for component-level code splitting
Optimize bundle size with proper tree shaking
Implement proper caching strategies for static and dynamic content
Use Next.js built-in performance monitoring

# Frontend Performance
Implement proper memoization with React.memo and useMemo
Use useCallback for stable function references
Implement virtual scrolling for large lists
Optimize re-renders with proper dependency arrays
Use proper key props for list rendering
Implement proper loading states and progressive enhancement

# ===== TESTING STRATEGIES =====

# Frontend Testing
Use Jest and React Testing Library for unit and integration tests
Implement proper test coverage for components and hooks
Create mock implementations for Frappe API calls
Use MSW (Mock Service Worker) for API mocking in tests
Implement proper accessibility testing with jest-axe
Create visual regression tests with tools like Chromatic

# End-to-End Testing
Use Playwright or Cypress for E2E testing
Test critical user flows including authentication
Implement proper test data setup and teardown
Test integration between Next.js frontend and Frappe backend
Create tests for different user roles and permissions
Implement proper error scenario testing

# ===== BUILD AND DEPLOYMENT =====

# Next.js Build Configuration
Configure next.config.js for proper build optimization
Set up proper environment variable handling
Implement proper asset optimization and compression
Configure proper routing and redirects
Set up proper security headers and CSP
Implement proper internationalization if needed

# Deployment Strategies
Create Docker configurations for containerized deployment
Set up proper CI/CD pipelines for automated deployment
Implement proper environment-specific configurations
Set up proper monitoring and logging for production
Create proper backup and rollback strategies
Implement proper SSL/TLS configuration

# ===== UNIFIED APP INTEGRATION =====

# Single App Architecture
Package frontend and backend as one unified Frappe app
Ensure single installation process with bench get-app and bench install-app
Create unified app structure where frontend is part of the Frappe app
Implement single-domain deployment (no separate frontend/backend URLs)
Use same server, same session, same authentication system
Avoid CORS issues by serving everything from the same origin

# Shared Session Management
Use Frappe's built-in session management for both frontend and backend
Implement session-based authentication that works across all app components
Ensure user login state is consistent between Frappe views and Next.js components
Use the same session cookies for all authentication needs
Implement unified logout that clears session for entire app
Handle session expiration consistently across frontend and backend

# Integrated Routing and Navigation
Create seamless navigation between Frappe desk views and Next.js pages
Implement unified URL structure that feels like one application
Use Frappe's routing system to serve Next.js pages when appropriate
Ensure breadcrumbs and navigation work consistently across the app
Implement proper deep linking that works for both Frappe and Next.js routes
Create unified search that works across all app content

# Same-Server Communication Patterns
Use relative URLs for all API calls (no external API endpoints)
Implement direct server-side communication between components
Use Frappe's built-in request handling for all data operations
Ensure all API calls use the same authentication context
Implement proper error handling that's consistent across the app
Use Frappe's built-in caching and performance optimizations

# Unified Data and State Management
Ensure database changes reflect immediately across all app components
Use Frappe's built-in real-time updates (Socket.IO) for live data sync
Implement consistent data validation rules across frontend and backend
Use the same DocType definitions for both API responses and frontend types
Ensure permissions and role-based access work consistently everywhere
Implement unified audit trails and logging across all app operations

# Integration with Frappe Deployment
Ensure Next.js frontend integrates seamlessly with Frappe bench
Create proper build scripts that work with Frappe app installation
Implement proper asset serving through Frappe's static file system
Set up integrated development workflow with bench start
Ensure proper session sharing between all app components
Create installation scripts similar to Frappe CRM approach
Package all frontend assets as part of the Frappe app structure

# Unified Build and Asset Management
Create build process that compiles Next.js into Frappe app structure
Ensure all static assets are served through Frappe's asset pipeline
Implement proper asset versioning and caching strategies
Create unified minification and optimization for all app assets
Ensure proper source maps and debugging for integrated development
Implement hot reloading that works for both frontend and backend changes

# ===== DEVELOPMENT WORKFLOW =====

# Development Environment
Set up proper development server configuration
Implement hot reloading for both frontend and backend changes
Create proper development database seeding scripts
Set up proper debugging configuration for both frontend and backend
Implement proper linting and formatting with ESLint and Prettier
Create proper Git hooks for code quality enforcement

# Code Organization
Follow consistent file and folder naming conventions
Implement proper import/export patterns
Create proper documentation for components and APIs
Use proper commit message conventions
Implement proper code review processes
Create proper development guidelines and standards

# ===== DEPLOYMENT CONSIDERATIONS =====

# Production Readiness
Include all dependencies in requirements.txt and package.json
Set up proper logging configuration for both frontend and backend
Implement health check endpoints for monitoring
Configure proper error pages and fallbacks
Set up database migrations in patches.txt
Test installation and migration procedures
Create proper production build and deployment scripts
Implement proper monitoring and alerting systems
