# .builderrules for Frappe Framework App Development
# This file guides Builder.io CLI on how to generate code for Frappe applications

# ===== FRAPPE FRAMEWORK CONVENTIONS =====

# Project Structure
Follow the standard Frappe app directory structure:
- Root level: setup.py, requirements.txt, MANIFEST.in, README.md
- App directory: {app_name}/ containing __init__.py, hooks.py, modules.txt, patches.txt
- Module directories: {app_name}/{module_name}/ with __init__.py
- DocType directories: {app_name}/{module_name}/doctype/{doctype_name}/
- API directories: {app_name}/api/ for REST API endpoints
- Config directories: {app_name}/config/ for desktop.py, workspace.py
- Templates: {app_name}/templates/ for web templates
- Public assets: {app_name}/public/ for CSS, JS, images

# ===== PYTHON CODING CONVENTIONS =====

# General Python Guidelines
Use Python 3.6+ syntax and features
Follow PEP 8 style guidelines for Python code
Use snake_case for function names, variables, and file names
Use PascalCase for class names and DocType names
Add docstrings to all functions and classes using Google style
Use type hints where appropriate

# Frappe-specific Python Patterns
Import frappe at the top of Python files: import frappe
Use frappe.whitelist() decorator for API methods accessible via REST
Use frappe.get_doc() to fetch documents, frappe.get_all() for lists
Handle exceptions with frappe.throw() for user-facing errors
Use frappe.log_error() for logging errors
Validate permissions with frappe.has_permission()
Use frappe.db.get_value() for single field queries
Use frappe.utils for date/time operations and utilities

# DocType Controller Classes
Create controller classes that inherit from frappe.model.document.Document
Override validate(), before_save(), after_insert(), on_submit() methods as needed
Use self.get() and self.set() to access and modify field values
Implement custom validation logic in validate() method
Use frappe.msgprint() for user notifications

# ===== JAVASCRIPT CONVENTIONS =====

# Client-side JavaScript (DocType JS)
Use frappe.ui.form.on() to bind form events
Access form fields with frm.doc.fieldname
Use frm.set_value() to update field values programmatically
Implement field validation with frappe.validated = false
Use frappe.call() for server-side method calls
Handle async operations with promises or async/await
Use frappe.msgprint() for user notifications

# Modern JavaScript Practices
Use ES6+ features: const/let, arrow functions, template literals
Use async/await for asynchronous operations
Implement proper error handling with try/catch blocks
Use destructuring for object and array operations
Prefer functional programming patterns where appropriate

# ===== API DEVELOPMENT =====

# REST API Endpoints
Place API methods in {app_name}/api/ directory
Use @frappe.whitelist() decorator for all API endpoints
Return JSON responses with consistent structure
Implement proper error handling and status codes
Use frappe.form_dict to access request parameters
Validate input parameters and permissions
Document API endpoints with docstrings

# API Response Format
Return consistent JSON structure: {"message": "success", "data": {...}}
Use HTTP status codes appropriately (200, 400, 401, 404, 500)
Include error messages in response for failed requests
Implement pagination for list endpoints

# ===== DOCTYPE DEVELOPMENT =====

# DocType JSON Schema
Use lowercase with underscores for fieldnames (e.g., "full_name")
Set appropriate fieldtypes: Data, Text, Select, Link, Date, Datetime, Check, etc.
Configure field properties: label, mandatory, read_only, hidden, depends_on
Set up proper field ordering with field_order array
Configure permissions for different roles
Set naming patterns using naming_rule and autoname

# DocType Field Guidelines
Use Link fields for relationships to other DocTypes
Set fetch_from property to auto-populate fields from linked records
Use Select fields with options for predefined choices
Implement field dependencies with depends_on property
Set default values where appropriate
Configure field validation with validation rules

# ===== HOOKS.PY CONFIGURATION =====

# App Metadata
Define app_name, app_title, app_publisher, app_description, app_email
Set app_license (typically "MIT" or "GPL")
Configure app_include_css and app_include_js for global assets
Set up desktop and workspace configurations

# Event Hooks
Use doc_events to hook into document lifecycle events
Configure scheduler_events for background tasks
Set up authentication hooks if needed
Define custom permissions with permission_query_conditions

# ===== TESTING CONVENTIONS =====

# Unit Tests
Create test files with test_ prefix in doctype directories
Use frappe.test_runner for running tests
Inherit from unittest.TestCase or frappe.tests.utils.FrappeTestCase
Create test data using frappe.get_doc().insert()
Clean up test data in tearDown() method
Test both positive and negative scenarios

# ===== SECURITY BEST PRACTICES =====

# Permission Management
Always check permissions before data operations
Use frappe.has_permission() to validate access
Implement role-based access control
Validate user input to prevent injection attacks
Use frappe.safe_decode() for user input processing
Implement CSRF protection for forms

# ===== PERFORMANCE GUIDELINES =====

# Database Operations
Use frappe.db.get_all() with specific fields instead of get_doc() for lists
Implement database indexes for frequently queried fields
Use frappe.db.sql() for complex queries with proper parameterization
Avoid N+1 query problems by batching operations
Use caching with frappe.cache() for expensive operations

# ===== FILE ORGANIZATION =====

# Module Structure
Group related DocTypes in the same module
Keep API endpoints organized by functionality
Separate utility functions into utils.py files
Use __init__.py files to make directories Python packages
Follow consistent naming conventions across the project

# ===== DOCUMENTATION =====

# Code Documentation
Add comprehensive docstrings to all public functions and classes
Include parameter types and return value descriptions
Document complex business logic with inline comments
Create README.md files for modules explaining their purpose
Document API endpoints with request/response examples

# ===== INTEGRATION PATTERNS =====

# Third-party Integrations
Create separate modules for external service integrations
Use environment variables for API keys and configuration
Implement proper error handling for external API calls
Add retry logic for network operations
Log integration activities for debugging

# ===== DEPLOYMENT CONSIDERATIONS =====

# Production Readiness
Include all dependencies in requirements.txt
Set up proper logging configuration
Implement health check endpoints
Configure proper error pages
Set up database migrations in patches.txt
Test installation and migration procedures

